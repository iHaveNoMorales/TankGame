<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
	<style>
		canvas {
			border:1px solid black;
			float:left;
		}
	</style>
  </head>
  <body>
	<canvas width="900" height="500" id="can"></canvas>
	<input type="text" id="input">
	<script>
		var px = 200;
		var py = 200;
		var canvas = document.getElementById("can");
		var cx = canvas.getContext("2d");
		var prot = 0;
		var preload = 0;
		var preloadc = 40;
		var pspeed = 5;
		var pyvel = 0;
		var pxvel = 0;
		var textVal = document.getElementById("input").value;
		var pmaxhealth = 100;
		var phealth = pmaxhealth;
		var precoverc = 50;
		var precover = 0;
		var fc = 0;
		var ammo = 10;
		var movePage = '';
		
		
		var timeScale = 1;
		//var ammoc = 10;
		
		
		var vax = [200, 300, 200, 100];
		var vay = [100, 200, 300, 200];
		var vbxNO = [20, 80, 300, 20];
		var vbyNO = [20, 20, 300, 80];
		var form = 'circle';
		var enemyForm = false;
		var grav = 0.01;
		var pageOn = 0;
		
		
		
		var shells = [];
		
		var w = new Wall(100, 100, 25, 150);
		
		var w7 = new Wall(300, 100, 50, 150);
		var levelOne = [[new Tank(850, 450), new Tank(850, 50), new Tank(50, 50), new Tank(50, 450)],[new Wall(100, 100, 25, 150), new Wall(250, 75, 150, 25), new Wall(500, 100, 200, 200)],[new AmmoPack(400, 400)]];
		var levels = [tutorial, levelOne]; //tank wall ammo
		
		
		var ammoPacks = [new AmmoPack(400, 400)];
		

		var tutorial = [new Tank (800, 225, 0, true), new Wall(150,150, 25, 200), new AmmoPack(200, 225)]; //tank, wall, ammo packs

		var gameObjects = levelOne;
		var enemyBase = new Image();
		var enemyCannon = new Image();
		var explosion = new Image();
		var pBase = new Image();
		var pCannon = new Image();
		var pShot = new Image();
		var eShot = new Image();
		var aPack = new Image();
		var numTanks = 14; 
		
		var screen = 3;
		
		var mouseX;
		var mouseY;
		
		enemyBase.src = 'RedBase.png';
		enemyCannon.src = 'RedCannon.png';
		explosion.src = 'explosion.png';
		pBase.src = 'BlueBase.png';
		pCannon.src = 'BlueCannon.png';
		pShot.src = 'BlueShot.png';
		eShot.src = 'RedShot.png';
		aPack.src = 'AmmoPack.png';
		var tanks = [new Tank(850, 450), new Tank(850, 50), new Tank(50, 50), new Tank(50, 450)];
		//tanks.push(new Tank(500, 300));
		//tanks.push(new Tank(00, 300));
		
		var clicked = false;
		canvas.addEventListener("mousemove", getMouseCoords, false);
		canvas.addEventListener("mousedown", function(event){clicked = true;}, false);
		canvas.addEventListener("mouseup", function(event){clicked = false;}, false);
		
		
		
		
		function getMouseCoords(event) {
			var clickX = event.clientX;		//x and y relative to the 
			var clickY = event.clientY;
			
			var targ = event.target;
			rec = targ.getBoundingClientRect();
			var relX = rec.left;
			var relY = rec.top;
			mouseX = clickX-relX;
			mouseY = clickY-relY;
			cx.font = '10px Arial';
			
			
			
			
		}
		var cannonRot = 0;//(Math.atan2(mouseY-py, mouseX-px)+Math.PI*2);
		
		
		//alert(collisionConvexPolygon(vax, vay, vbxNO, vbyNO ) );

		function collisionConvexPolygon ( vertsax, vertsay, vertsbx, vertsby ) {
			var alen = vertsax.length;
			var blen = vertsbx.length;
			// Loop for axes in Shape A
			for ( var i = 0, j = alen - 1; i < alen; j = i++ ) {
				// Get the axis
				var vx =    vertsax[ j ] - vertsax[ i ];
				var vy = -( vertsay[ j ] - vertsay[ i ] );
				var len = Math.sqrt( vx * vx + vy * vy );

				vx /= len;
				vy /= len;

				// Project shape A
				var max0 = vertsax[ 0 ] * vx + vertsay[ 0 ] * vy, min0 = max0;
				for ( k = 1; k < alen; k++ ) {
					var proja = vertsax[ k ] * vx + vertsay[ k ] * vy;

					if ( proja > max0 ) {
						max0 = proja;
					}
					else if ( proja < min0 ) {
						min0 = proja;
					}
				}
				// Project shape B
				var max1 = vertsbx[ 0 ] * vx + vertsby[ 0 ] * vy, min1 = max1;
				for ( var k = 1; k < blen; k++ ) {
					var projb = vertsbx[ k ] * vx + vertsby[ k ] * vy;

					if ( projb > max1 ) {
						max1 = projb;
					}
					else if ( projb < min1 ) {
						min1 = projb;
					}
				}
				// Test for gaps
				if ( !axisOverlap( min0, max0, min1, max1 ) ) {
					return false;
				}
			}
			// Loop for axes in Shape B (same as above)
			for ( var i = 0, j = blen - 1; i < blen; j = i++ ) {
				var vx =    vertsbx[ j ] - vertsbx[ i ];
				var vy = -( vertsby[ j ] - vertsby[ i ] );
				var len = Math.sqrt( vx * vx + vy * vy );

				vx /= len;
				vy /= len;

				var max0 = vertsax[ 0 ] * vx + vertsay[ 0 ] * vy, min0 = max0;
				for ( k = 1; k < alen; k++ ) {
					var proja = vertsax[ k ] * vx + vertsay[ k ] * vy;

					if ( proja > max0 ) {
						max0 = proja;
					}
					else if ( proja < min0 ) {
						min0 = proja;
					}
				}
				var max1 = vertsbx[ 0 ] * vx + vertsby[ 0 ] * vy, min1 = max1;
				for ( var k = 1; k < blen; k++ ) {
					var projb = vertsbx[ k ] * vx + vertsby[ k ] * vy;

					if ( projb > max1 ) {
						max1 = projb;
					}
					else if ( projb < min1 ) {
						min1 = projb;
					}
				}
				if ( !axisOverlap( min0, max0, min1, max1 ) ) {
					return false;
				}
			}
			return true;
		}
		

		function axisOverlap ( a0, a1, b0, b1 ) {
			return !( a0 > b1 || b0 > a1 );
		}
		
		var keys = {};    
		window.addEventListener('keydown',function(e){
			keys[e.keyCode || e.which] = true;
		},true);    
		window.addEventListener('keyup',function(e){
			keys[e.keyCode || e.which] = false;
		},true);
		var protvelc = 0.08;
		var protvel = protvelc;
		
		var tempPage;
		function keyControl(){
			
			if(phealth>0){ //tank doesn't move after death
			
				if(keys[87]){
					pyvel = -1*Math.cos(prot)*pspeed*timeScale;
					pxvel = Math.sin(prot)*pspeed*timeScale;
					
				}
				if(keys[83]){
					pyvel = Math.cos(prot)*pspeed*timeScale;
					pxvel = -1*Math.sin(prot)*pspeed*timeScale;
				}
				if(keys[68]){
					prot+=protvel*timeScale;
					
				}
				if(keys[65]){
					prot-=protvel*timeScale;
				}
				if(keys[32]){
					protvel = protvelc*1.25;
				} else {
					protvel = protvelc;
				}
				if(keys[81] && movePage == ''){
					movePage = 'left';
					tempPage = pageOn;
					
				}
				if(keys[69] && movePage == ''){
					movePage = 'right';
					tempPage = pageOn;
				}
				if(movePage == 'right'){
					if(pageOn < tempPage+1){
						pageOn+=0.05;
					} else {
						movePage = '';
					}
				}
				if(movePage == 'left'){
					if(pageOn > tempPage-1){
						pageOn-=0.05;
					} else {
						movePage = '';
					}
				}
				
				py+=pyvel;
				px+=pxvel;
				if(pInWall()){
					py-=pyvel;
					px-=pxvel;
				}
				pyvel = 0;
				pxvel = 0;
			}
			
		}
		
		function pInWall(){
			for(g = 0; g < gameObjects.length; g++){
				obj = gameObjects[g];
				if (px - 20 < obj.x + obj.w &&
				px + 20 > obj.x &&
				py - 20 < obj.y + obj.h &&
				py + 20 > obj.y ){
					return true;
				}
			}
			return false;
			
		}
		
		function Attribute(s, a){
		
		}
		
		function Tank(x, y, p, t){
			this.t=t;
			if(this.t==undefined){
				t=false;
			}
			this.x = x;
			this.y = y;
			this.rot = 0;
			this.blocked = false;
			this.speed = 1;
			this.targ = new Point(px, py);
			this.tempPath = false;
			this.pathTimer = 0;
			this.p = p;
			this.pathcheckConstant = 30;
			this.srot = Math.atan2(this.targ.y-this.y, this.targ.x-this.x); //smooth rotation;
			this.turnVel = 0.04;
			this.formation = enemyForm;
			this.shotSpeed = 10;
			this.reload = 65;
			this.reloading = Math.floor(Math.random()*this.reload);
			
			
			
			this.prev = [this.x, this.y, this.rot];
			this.xvel = 0;
			this.yvel = 0;
			
			this.shotTarg = new Point(px, py);
			this.recoverc = 50;
			this.recover = this.recoverc;

			this.maxhealth = 25;
			this.health = this.maxhealth;
			this.inWall = false;
			
			this.getP = function(){
				for(d = 0; d < tanks.length; d++){
					if(tanks[d].x == this.x && tanks[d].y == this.y){
						this.p = d;
					}
				}
			}
			this.draw = function(){
				cx.fillStyle = "black";
				
				cx.save();
				cx.translate(this.x, this.y);
				if(this.formation && dist(this.x, this.y, this.targ.x, this.targ.y) < 2){
					cx.rotate(Math.atan2(py-this.y, px-this.x));
				} else {
					cx.rotate(this.srot);
				}
				
				cx.rotate(Math.PI/2);
				cx.drawImage(enemyBase, -25, -25, 50, 50);
				cx.rotate(-Math.PI/2);
				cx.restore();
				cx.save();
				cx.translate(this.x, this.y);
				cx.rotate(Math.PI/2);
				
				cx.rotate(Math.atan2(py-this.y, px-this.x));
				cx.drawImage(enemyCannon, -25, -1*(37*(50/64)), 50, 50);
				cx.rotate(-Math.atan2(py-this.y, px-this.x));
				cx.rotate(-Math.PI/2);
				
				//console.log(this.shotTarg.x+", "+this.shotTarg.y);
				//cx.fillRect(-25, -25, 50, 50);
				cx.fillStyle="blue";
				//cx.fillRect(-25, -25, 25, 50);
				
				cx.fillStyle = "rgba(0, 0, 0, 0.1)";
				//cx.fillRect(-25, -25, dist(this.x, this.y, px, py), 50);
				
				
				
				
				cx.restore();
				cx.fillStyle = "black";
				cx.fillText(this.p, this.x, this.y-20);
				cx.beginPath();
				cx.moveTo(this.x, this.y);
				//cx.strokeStyle = 'red';
				//cx.lineTo(px, py);
				cx.stroke();
				cx.closePath();
				
				//cx.fillRect(this.shotTarg.x, this.shotTarg.y, 15, 15);
					
				
				
			}
			
			
			
			this.shoot = function(rota){
				
				this.shotTarg = new Point(px, py);
				d = dist(this.x, this.y, this.shotTarg.x, this.shotTarg.y);
				
				
				if(this.reloading == 0){// && d < 150){
					temps = new Shell(this.x, this.y, Math.cos(rota)*this.shotSpeed*timeScale, Math.sin(rota)*this.shotSpeed*timeScale, rota, this.shotTarg, false);
					if(clicked){
						//console.log(temps);
					}
					shells.push(temps);
					this.reloading = this.reload;
				}
				if(this.reloading > 0){
					this.reloading--;
				
				}
				
				
			}
			
			
			this.think = function(){
				if(this.t==false){
					this.blocked = this.checkObj(gameObjects, Math.atan2(this.targ.y-this.y, this.targ.x-this.x));
					this.shoot(Math.atan2(this.shotTarg.y-this.y, this.shotTarg.x-this.x));
					this.hurt();
					if(!(this.x > 0 || this.x <= 0)){
						tanks.splice(this.p, 1);
					}
					this.getP();
					this.blocked = this.checkObj(gameObjects, Math.atan2(this.targ.y-this.y, this.targ.x-this.x));
					this.shoot(Math.atan2(this.shotTarg.y-this.y, this.shotTarg.x-this.x));
					this.hurt();
					if(!(this.x > 0 || this.x <= 0)){
						tanks.splice(this.p, 1);
					}
					if(!this.formation){
						this.targ = new Point(px, py);
					}
				
					this.swarm();
					if(!this.blocked){
						if(!this.formation){
							this.targ = new Point(px, py);
						}
						
						this.swarm();
						if(!this.blocked){
							if(!this.formation){
								if(dist(this.x, this.y, this.targ.x, this.targ.y) > 80){
									this.x += Math.cos(this.rot)*this.speed*timeScale;
									this.y += Math.sin(this.rot)*this.speed*timeScale;
								}
							}
							else {
								if(dist(this.x, this.y, this.targ.x, this.targ.y) > 2){
									this.x += Math.cos(this.rot)*this.speed*timeScale;
									this.y += Math.sin(this.rot)*this.speed*timeScale;
								}
							}
							this.rot = Math.atan2(this.targ.y-this.y, this.targ.x-this.x);
							this.tempPath = false;
						}

						this.rot = Math.atan2(this.targ.y-this.y, this.targ.x-this.x);
						this.tempPath = false;
					}
					
						if(this.blocked && !this.tempPath){// && !this.inWall){
							
								this.pathFind();
								
						}
						
						//console.log(this.tempPath + ", "+this.blocked);
						

						//////console.log(this.blocked+", "+this.tempPath);
						if(this.tempPath){
								if(!this.blocked){
									this.x += Math.cos(this.rot)*this.speed*timeScale;
									this.y += Math.sin(this.rot)*this.speed*timeScale;
								}
							
							if(this.pathTimer == 0){
								this.pathFind();
							}
							if(this.pathTimer > 0){
								this.pathTimer-=timeScale;
							}

						
						}
					//console.log(this.tempPath + ", "+this.blocked);
					
					//////console.log(this.blocked+", "+this.tempPath);
						if(this.tempPath){
								
							this.x += Math.cos(this.rot)*this.speed*timeScale;
							this.y += Math.sin(this.rot)*this.speed*timeScale;
								
						}
						if(this.pathTimer == 0){
							this.pathFind();
						}
					}
					
					if(this.rot > this.srot){
						this.srot+=this.turnVel*timeScale;
					}
					if(this.rot < this.srot){
						this.srot-=this.turnVel*timeScale;
					}
					if(Math.abs(this.rot-this.srot) < this.turnVel*timeScale){
						this.srot = this.rot;
					}
					
					
					this.prev = [this.x, this.y, this.rot];
				}
					
			
			}
			
			this.swarm = function(){
				for (k = 0; k < tanks.length; k++) {
					t = tanks[k];
					if(!this.formation){
						if (t.x != this.x && t.y != this.y && dist(this.x, this.y, px, py) > dist(t.x, t.y, px, py) && dist(t.x, t.y, this.x, this.y) < 50) {
							this.xvel = -1*Math.cos(this.rot)*this.speed*timeScale;
							this.yvel = -1*Math.sin(this.rot)*this.speed*timeScale;
						}
					} else {
						if (k.x != this.x && t.p > this.p && dist(t.x, t.y, this.x, this.y) < 0) {
							this.x -= Math.cos(this.rot)*this.speed*timeScale;
							this.y -= Math.sin(this.rot)*this.speed*timeScale;
						}
					}					
				}
				this.x+=this.xvel;
				this.y+=this.yvel;
				this.xvel = 0;
				this.yvel = 0;
				console.log(this.reloading+", "+this.reload);
			}
			
			this.hurt = function(){
				for(e = 0; e < shells.length; e++){
					if(shells[e].exploding == 1){
						if(dist(shells[e].x, shells[e].y, this.x, this.y) <= shells[e].rad && this.recover == 0){
							this.health -=5;
							this.recover = this.recoverc;
						}
					}
				}
				if(this.recover > 0){
					this.recover -=timeScale;
				}
				
				cx.beginPath();
				
				
				if(this.health > (this.maxhealth*4)/5 && this.health <= (this.maxhealth*5)/5){
					cx.strokeStyle = 'rgb(173, 209, 14)';
				}
				if(this.health > (this.maxhealth*3)/5 && this.health <= (this.maxhealth*4)/5){
					cx.strokeStyle = 'rgb(209, 192, 14)';
				}
				if(this.health > (this.maxhealth*2)/5 && this.health <= (this.maxhealth*3)/5){
					cx.strokeStyle = 'rgb(209, 154, 14)';
				}
				if(this.health > (this.maxhealth*1)/5 && this.health <= (this.maxhealth*2)/5){
					cx.strokeStyle = 'rgb(209, 105, 14)';
				}
				if(this.health > 0 && this.health <= (this.maxhealth*1)/5){
					cx.strokeStyle = 'rgb(209, 50, 14)';
				}
				
				cx.arc(this.x, this.y, 40, 0, (this.health/this.maxhealth)*(Math.PI * 2));
				
				//cx.fill();
				cx.lineWidth = 7;
				cx.stroke();
				cx.lineWidth = 1;
				cx.closePath();
				
				
			}
			
			this.pathFind = function(){
				tRot = this.rot;
				degrees = [];
				//////console.log("1");
				j = 0;
				//step 1, check all angles (increment by 5 to save time), if these angles don't result in blocked path add to list
				while(j < 360){
					if(!this.checkObj(gameObjects, j*(Math.PI/180))){
						degrees.push(j*(Math.PI/180));
					}
					j+=5;
				}
				
				//setting up step 2, basic minimum search
				targetr = Math.atan2(this.targ.y-this.y, this.targ.x-this.x); //the goal is to find minimum distance between a degree in degrees and the exact angle from tank to player
				if(targetr < 0){
					targetr+=2*Math.PI;
				}
				//////console.log(targetr*(180/Math.PI));
				mind = Math.abs(degrees[0]-targetr); //min distance (in radians)
				minpos = 0; //position of degree resulting in min distance
				//////console.log("3");
				//////console.log(degrees.length);
				//step 2, loop through degrees and find minimum separation between angle and target angle.
				for(k = 0; k < degrees.length; k++){
				
					if(degrees[k] > targetr+Math.PI){ //passing 180 degrees (PI radians) gets you closer to target, this logic means angles greater than 180 are treated as getting closer
					//////console.log("yee");
					//////console.log((180/Math.PI)*degrees[k]+", "+(180/Math.PI)*(degrees[k]-(2*(degrees[k]-Math.PI)))); 
						if(Math.abs(((degrees[k]-(2*(degrees[k]-Math.PI)))-targetr)) < mind){
						
							mind = Math.abs(degrees[k]-targetr);
							minpos = k;
						}
					} else {
						if(Math.abs(degrees[k]-targetr) < mind){
							mind = Math.abs(degrees[k]-targetr);
							minpos = k;
						}
					}
				}
				//////console.log("4");
				if(Math.abs(Math.PI-Math.abs(this.rot-degrees[minpos])) < (5*(Math.PI/180))){ //if the angle to pathfind to is close to 180 (resulting from bug), don't do it and attempt to pathfind again
					this.pathTimer = 5;
					this.tempPath = true;
					//////console.log("yee");
				} else {
					this.rot = degrees[minpos];
				}
				
				this.pathTimer = this.pathcheckConstant; //resetting countdown
				this.tempPath = true; //prevents pathfinding from happening every frame
				//////console.log("5");
			}
			
			this.checkObj = function(objects, rota){
				for(i = 0; i < objects.length; i++){
					c = objects[i].coords();
					
					if(dist(c[0][0]+(c[0][2]-c[0][0])/2, c[1][0]+(c[1][2]-c[1][0])/2, this.x, this.y) < 500){
						
						if (this.detect(c, rota)){
							return this.detect(c, rota);
						}
					}
					if(this.x-50 < objects[i].x + objects[i].w && this.x+50 > objects[i].x &&  this.y-50 < objects[i].y + objects[i].h && this.y+50 > objects[i].y ){
						this.inWall = true;
						//console.log("YEEEEE");
					} else {
						this.inWall = false;
					}
				}
				return false;
				
			}
			
			this.collideWalls = function(){
				
			}
			
			this.detect = function(coords, rota){
				var rotM = [[Math.cos(-rota), Math.sin(-rota)], [-1*Math.sin(-rota), Math.cos(-rota)]];
				////////console.log(rotM);
				var m1 = multiply(rotM, [[-25], [-25]]);
				
				var m2 = multiply(rotM, [[-25], [25]]);
				
				var m3 = multiply(rotM, [[-25+dist(this.x, this.y, px, py)], [0+25]]);
				
				var m4 = multiply(rotM, [[-25+dist(this.x, this.y, px, py)], [-25]]);
				
				
				//his.x-25)*Math.cos(this.rot)-((this.y-25)*Math.sin(this.rot))],[(this.x-25)*Math.sin(this.rot)+((this.y-25)*Math.cos(this.rot))]];
				////////console.log(typeof(m1[0][0]));
				boxX = [(m1[0][0]+this.x), m2[0][0]+this.x, m3[0][0]+this.x, m4[0][0]+this.x];
				boxY = [m1[1][0]+this.y, m2[1][0]+this.y, m3[1][0]+this.y, m4[1][0]+this.y];
				cx.fillStyle = "rgba(0, 0, 255, 0.1)";
				cx.fillStyle="black";
				//cx.fillText(""+m1[0][0] + " and " + this.x + "and " + (m1[0] + this.x), 30, 30 );
				//maunu addition
				//cx.fillRect(boxX[0], boxY[0], 500, 500);
				
			//	cx.fillRect(boxX[0], boxY[0], boxX[2]-boxX[0], boxY[2]-boxY[0]);
				cx.fillStyle = "black";
				cx.save();
			//	cx.translate(this.x, this.y);
				/*cx.fillRect(m1[0], m1[1], 5, 5);
				cx.fillRect(m2[0], m2[1], 5, 5);
				cx.fillRect(m3[0], m3[1], 5, 5);
				cx.fillRect(m4[0], m4[1], 5, 5);*/
				cx.restore();
				////////console.log(m4);
				return collisionConvexPolygon(boxX, boxY, coords[0], coords[1]);
				
				
			}
			
			this.act = function(){
				
				this.draw();
				if(phealth>0){
					this.think(); //stops enemies from shooting dead player
				}
			}
			
			
		};
		
		function Shell(x, y, vx, vy, rota, target, play){
			this.vx = vx;
			this.vy = vy;
			this.x = x;
			this.ox = x; 
			this.oy = y; //original x and y
			this.s = 12;
			this.y = y;
			this.rot = rota;
			this.rad = 0;
			this.distance = 0;// dist(this.ox, this.oy, this.x, this.y);
			this.target = target;
			this.exploding = 0;
			this.isplayer = play;
			this.draw = function(){
				cx.save();
				cx.translate(this.x, this.y);
				cx.rotate(this.rot);
				if(this.isplayer){
					cx.drawImage(pShot, -(this.s/2), -(this.s/2), this.s, this.s);
				}
				if(!this.isplayer){
					cx.drawImage(eShot, -(this.s/2), -(this.s/2), this.s, this.s);
				}
				cx.restore();
			}
			
			
			
			this.act = function(){
				this.distance = dist(this.ox, this.oy, this.x, this.y);
				if(this.exploding == 0){
					this.move();
					this.draw();
					
					
				} else if(this.exploding == 1){
					this.explode();
				}
				if(!play){
					if((dist(this.x, this.y, this.target.x, this.target.y) < 20 && this.exploding == 0) || (this.distance > 2500 && this.exploding == 0)){
						this.exploding = 1;
						//console.log(this.exploding);
					}
				} else {
					if(tanks.length==0 && (this.distance > 250 && this.exploding == 0)){
						this.exploding=1;
					}
					for(o = 0; o < tanks.length; o++){
						if((dist(this.x, this.y, tanks[o].x, tanks[o].y) < 20 && this.exploding == 0) || (this.distance > 250 && this.exploding == 0)){
							this.exploding = 1;
							break;
							//console.log(this.exploding);
						}
					}
				}
				
			}
			
			this.move = function(){
				this.x+=this.vx*timeScale;
				this.y+=this.vy*timeScale;
			}
			
			this.explode = function(){
				this.rad+=15*timeScale;
				cx.save();
				cx.translate(this.x, this.y);
				
				cx.drawImage(explosion, -0.5*this.rad, -0.5*((6/5)*this.rad), this.rad, (6/5)*this.rad);
				cx.restore();
				if(this.rad > 90){
					this.exploding = -1;
				}
			}
			
			
		}
		
		function Point(x, y){
			this.x = x;
			this.y = y;
		}
		
		function dist(x1, y1, x2, y2){
			var a = x1 - x2
			var b = y1 - y2

			return Math.sqrt( a*a + b*b );
		}
		
		function multiply(m1, m2) {
			var result = [];
			for (var i = 0; i < m1.length; i++) {
				result[i] = [];
				for (var j = 0; j < m2[0].length; j++) {
					var sum = 0;
					for (var k = 0; k < m1[0].length; k++) {
						sum += m1[i][k] * m2[k][j];
					}
					result[i][j] = sum;
				}
			}
			return result;
		}
		function Wall(x, y, w, h){
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;
			this.draw = function(){
				cx.fillStyle = "black";
				cx.fillRect(this.x, this.y, this.w, this.h);
				for(p = 0; p < shells.length; p++){
					s = shells[p];
					if(s.x+(s.s/2) > this.x && s.x-(s.s/2) < this.x+this.w && s.y+(s.s/2) > this.y && s.y-(s.s/2) < this.y+this.h){
						shells[p].exploding = 1;
					}
				}
			}
			this.coords = function(){
				return [[this.x, this.x+w, this.x+w, this.x], [this.y, this.y, this.y+h, this.y+h]];
			}
		}
		
		function display(m) {
		  for (var r = 0; r < m.length; ++r) {
			document.write('&nbsp;&nbsp;'+m[r].join(' ')+'<br />');
		  }
		}
		
		
		var player = function(){
			cx.fillStyle = "black";
			cx.save();
			cx.translate(px, py);
			
			cx.rotate(prot);
			cx.drawImage(pBase, -25, -25, 50, 50);
			cx.restore();
			cx.save();
			cx.translate(px, py);
			cx.rotate(cannonRot+Math.PI/2);
			cx.drawImage(pCannon, -25, -1*(37*(50/64)), 50, 50);
			cx.fillStyle = "rgba(0, 0, 0, 0)";
			cx.strokeStyle = "black";
			cx.beginPath();
			cx.arc(0, 0, 150, 0, Math.PI * 2);
			cx.fill();
			cx.stroke();
			cx.closePath();
			//cx.fillRect(-25, -25, 50, 50);
			cx.restore();
			if(clicked && preload == 0 && ammo > 0){
				temps = new Shell(px, py, Math.cos(cannonRot)*10, Math.sin(cannonRot)*10, cannonRot, new Point(-200, -200), true);
				shells.push(temps);
				preload = preloadc;
				ammo-=timeScale;
			}
			if(preload > 0){
				preload-=timeScale;
			}
			targRot = (Math.atan2(mouseY-py, mouseX-px)+Math.PI*2);
			var canRotSpeed = 0.08;
			//cannonRot %= (Math.PI*2);
			
			if(cannonRot > targRot){
				if((Math.abs(cannonRot-(Math.PI*3)) + Math.abs(targRot-Math.PI)) < cannonRot-targRot){
					cannonRot+=canRotSpeed*timeScale;
				} else {
					cannonRot -= canRotSpeed*timeScale;
				}
			} else if (cannonRot < targRot){
				if((Math.abs(targRot - (Math.PI*3)) + Math.abs(cannonRot - Math.PI)) < targRot - cannonRot){
					cannonRot-=canRotSpeed*timeScale;
				} else {
					cannonRot += canRotSpeed*timeScale;
				}
			}
			
			if(cannonRot > Math.PI*3){
				cannonRot %= (Math.PI*2);
			}
			if(cannonRot < Math.PI){
				cannonRot += (Math.PI*2);
			}
			
			if(Math.abs(cannonRot-targRot) < canRotSpeed*timeScale){
				cannonRot = targRot;
			}
			cx.fillText(cannonRot+", "+targRot, 300, 300);
			for(q = 0; q < shells.length; q++){
				if(shells[q].exploding == 1){
					if(dist(shells[q].x, shells[q].y, px, py) <= shells[q].rad && precover == 0){

						phealth -= 10;
						precover = precoverc;
					}
				}
			}
			
			if(precover > 0){
				precover-=timeScale;
			}
			for(f = 0; f < ammo; f++){
				cx.drawImage(pShot, 5+((f)*12), 25, 10, 10);
			}
			//console.log(phealth);
		
			
		}
		function AmmoPack(x, y){
			this.x = x;
			this.y = y;
			this.w = 30;
			this.h = 30;
			this.draw = function(){
				cx.fillStyle = 'rgb(255, 0, 0)';
				cx.drawImage(aPack, this.x, this.y, this.w, this.h);
			}
			
			this.pickedUp = function(){
				if (px - 25 < this.x + this.w &&
				px + 25 > this.x &&
				py - 25 < this.y + this.h &&
				py + 25 > this.y ){
					return true;
				}
			}
			this.act = function(){
				if(this.pickedUp()){
					ammo+=5;
				}
				this.draw();
			}
		}
		
		
		var healthbar = function(){
			cx.fillStyle = 'rgba(0, 0, 0, 0)';
			cx.strokeStyle = "rgb(0, 0, 0)";
			cx.fillRect(5, 5, 100, 10);
			cx.strokeRect(5, 5, 100, 10);
			
			if(phealth > (pmaxhealth*4)/5 && phealth <= (pmaxhealth*5)/5){
				cx.fillStyle = 'rgb(173, 209, 14)';
			}
			if(phealth > (pmaxhealth*3)/5 && phealth <= (pmaxhealth*4)/5){
				cx.fillStyle = 'rgb(209, 192, 14)';
			}
			if(phealth > (pmaxhealth*2)/5 && phealth <= (pmaxhealth*3)/5){
				cx.fillStyle = 'rgb(209, 154, 14)';
			}
			if(phealth > (pmaxhealth*1)/5 && phealth <= (pmaxhealth*2)/5){
				cx.fillStyle = 'rgb(209, 105, 14)';
			}
			if(phealth > 0 && phealth <= (pmaxhealth*1)/5){
				cx.fillStyle = 'rgb(209, 50, 14)';
			}
			cx.fillRect(5, 5, (phealth/pmaxhealth)*100, 10);
		}
		//var ap = new AmmoPack(300, 400);
		var drawGame = function(){
			
			w.x++;
			
			background(255, 255, 255);
			for(t = 0; t < ammoPacks.length; t++){
				ammoPacks[t].act();
				if(ammoPacks[t].pickedUp()){
					ammoPacks.splice(t, 1);
					t--;
				}
			}
			healthbar();
			textVal = document.getElementById("input").value;
			if(textVal < tanks.length){
				if(textVal > 0){
					//console.log((tanks[textVal].x > 0 || tanks[textVal].x <=0));
				}
			}
			//////console.log(tanks[1].x+", "+tanks[1].y);
			
			for(k = 0; k < gameObjects.length; k++){
				gameObjects[k].draw();
			}
			for(h = 0; h < tanks.length; h++){
				tanks[h].act(); 
				//console.log(tanks.length+", "+h);
				if(tanks[h].health <= 0){
					tanks.splice(h, 1);
					if(tanks.length > 0){
						h--;
					}
					
				}
				
				
			}
			
			
			for(k = 0; k < shells.length; k++){
			
				//console.log(typeof(shells[k])+", "+shells[k].rad+", "+shells[k].exploding);
				
				
				//console.log(typeof(shells[k]));
				
				
				
				shells[k].act();
				if(shells[k].exploding == -1){
					shells.splice(k, 1);
					k--;
					if(shells.length == 0){
						break;
					}
					
				}
				
				
				
				//console.log(typeof(shells[k]));
				
				
				
				
			}
			
			//////console.log(tanks.length);
			if(phealth > 0){
				player();
			}
			keyControl();
			if(enemyForm){
				if(form == 'circle'){
					for(k = 0; k < tanks.length; k++){
						//cx.fillStyle = "black";
						//cx.fillRect(px+(100*(Math.cos(2*Math.PI*((k)/tanks.length)))), py+(100*(Math.sin(2*Math.PI*((k)/tanks.length)))), 5, 5);
						
						
						tanks[k].targ = new Point(px+100*(Math.cos(2*Math.PI*((k)/tanks.length))), py+100*(Math.sin(2*Math.PI*((k)/tanks.length))));
					}
				}
				if(form == 'v'){
					cons = 50;
					for(k = -1*(tanks.length/2)+1; k < (tanks.length/2); k++){
						////console.log("yeee");
						//if(k > tanks.length/2){
							cx.fillStyle = "black";
							cx.save();
							cx.translate(px, py);
							
								cx.fillRect(k*cons, -1*Math.abs(k*cons)+100, 5, 5);
							
							cx.restore();
							tanks[k+tanks.length/2].targ = new Point(px+k*cons, py+(-1*Math.abs(k*cons))+100);
						/*} else {
							
						}*/
					}
					tanks[0].targ = new Point(px, 100+py+cons/2);
				}
			}
			////console.log(form);
			
			fc++;
		}
		var loadAni = 500;
		function loading(){
			background(255, 255, 255);
			console.log(loadAni);
			loadAni--;
			if(loadAni == 0){
				screen = 1;
			}
			cx.font = 'italic 40px Arial';
			cx.fillStyle = 'rgb(50, 0, 0)';
			cx.textAlign = 'center';
			cx.fillText('Tanks', 450, 200);
			cx.fillStyle = "white";
			wide = cx.measureText('Tanks').width;
			if(900-((loadAni-200)*5) < 450-wide/2){
				cx.fillRect(450-wide/2, 150, wide, 100);
			} else {
				fc++;
				cx.fillRect(450-wide/2+(fc*5), 150, wide, 100);
			}
			if(loadAni < 390 && loadAni > 195){
				cx.save();
				cx.translate(900-((loadAni-200)*5), 185);
				cx.rotate(Math.PI/2);
				cx.drawImage(pBase, -25, -25, 50, 50);
				cx.drawImage(pCannon, -25, -25, 50, 50);
				cx.restore();
			}
			if(loadAni < 110){
				screen = 1;
				fc = 0;
			}
			
			
			
			
		}
		
		function Button(x, y, w, h, action, oncolor, offcolor, name, fontSize){
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;
			this.fontSize = fontSize;
			this.action = action;
			
			this.act = function(){
				if(mouseX > this.x-(this.w/2) && mouseX < this.x+(this.w/2) && mouseY > this.y-(this.h/2) && mouseY < this.y+(this.h/2)){
					cx.fillStyle = oncolor;
					if(clicked){
						this.action();
						
					}
				} else {
					cx.fillStyle = offcolor;
				}
				cx.fillRect(this.x-(this.w/2), this.y-(this.h/2), this.w, this.h);
				cx.font = 'bold '+this.fontSize+'px Arial';
				cx.fillStyle = 'rgb(0, 0, 0)';
				cx.textAlign = 'center';
				cx.fillText('Play', x, y+this.h/5);
				cx.strokeStyle = 'rgb(0, 0, 0)';
				cx.strokeRect(this.x-(this.w/2), this.y-(this.h/2), this.w, this.h);
			}
		}
		
		function menu(){
			background(255, 255, 255);
			playbutton = new Button(450, 100, 150, 50, function(){screen = 3;}, 'rgb(173, 173, 255)', 'rgb(203, 203, 255)', "Play", 30);
			if(screen == 1){
				playbutton.act();
			}
			console.log(screen);
			
			
		}
		var levelPanels = [];
		for(u = 0; u < 15; u++){
			levelPanels.push(new LevelPanel(u, tanks.length, 10, tanks, levelOne, ));
		}
		
		function LevelPanel(num, tankNum, ammoNum, tankList, wallList, ammoList){
			this.num = num;
			this.tankNum = tankNum;
			this.ammoNum = ammoNum;
			this.tankList = tankList;
			this.wallList = wallList;
			this.ammoList = ammoList;
			
			this.x = 0;
			this.y = 0;
			this.page = 0;
			this.b; new Button(this)
			this.draw = function(){
				this.b = new Button(this.x+(-900*pageOn), this.y+100, 75, 25, this.playLevel, 'rgb(173, 173, 255)', 'rgb(203, 203, 255)', "Play", 15)
				if(this.num%10 < 5){
					this.y = 75;
				} else {
					this.y = 275;
				}
				cx.save();
				cx.translate(-900*pageOn, 0);
				//console.log(-900*pageOn);
				this.page = Math.floor(this.num/10);
				
				this.x = 150+((num%5)*150)+(this.page*900);
				cx.fillStyle = 'rgb(0, 130, 255)';
				
		
				cx.fillRect(this.x-50, this.y, 100, 150);
				
				cx.fillStyle = "black";
				cx.font = '20px Arial';
				cx.textAlign = "center";
				if(num == 0){
					cx.fillText("Tutorial", this.x, this.y+40);
				} else {
					cx.fillText(num, this.x, this.y+40);
				}
				cx.restore();
				this.b.act();
				
			}
			this.playLevel = function(){
				
				
				tanks = levels[num][0];
				gameObjects = levels[num][1];
				ammoPacks = levels[num][2];
				px = 200;
				py = 200;
				ammo = ammoNum;
				ammoc = ammoNum;
				screen = 2;
				
			}
			
		}
		
		var levelSelect = function(){
			background(255, 255, 255);
			for(var v in levelPanels){
				levelPanels[v].draw();
				//console.log(levelPanels[v]);
			}
			
		}
		
		var background = function(r, g, b){
			cx.fillStyle = 'rgb('+r+','+g+','+b+')';
			cx.fillRect(0, 0, 900, 500);
		}
		var screenFunction = function(){
			
			//.log(screen);
			if(screen == 0){
				loading();
			} 
			if(screen == 1){
				menu();
				
			}
			if(screen == 2){
			
				drawGame();
				cx.fillStyle = 'rgb(0, 0, 0)';
			cx.fillText(mouseX+", "+mouseY, 0, 460);
			}
			if(screen == 3){
				levelSelect();
				keyControl();
			
			}
		}
		setInterval(screenFunction, 20);
		
		
		
	</script>
  </body>
</html>